<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>Hello World</title>
      <link href="/post/hello-world.html"/>
      <url>/post/hello-world.html</url>
      
        <content type="html"><![CDATA[<p><img src="/upload_image/test.jpg" alt=""></p><p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p><p>cover: <a href="http://ww3.sinaimg.cn/large/7853084cgw1f7vueqesr5j21jk0uh446.jpg" target="_blank" rel="noopener">http://ww3.sinaimg.cn/large/7853084cgw1f7vueqesr5j21jk0uh446.jpg</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> first </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java面试</title>
      <link href="/post/Java%E9%9D%A2%E8%AF%95.html"/>
      <url>/post/Java%E9%9D%A2%E8%AF%95.html</url>
      
        <content type="html"><![CDATA[<blockquote class="blockquote-center">网络上搜集的面试题</blockquote><h2 id="多线程面试题"><a href="#多线程面试题" class="headerlink" title="多线程面试题"></a>多线程面试题</h2><h3 id="进程和线程之间有什么不同？"><a href="#进程和线程之间有什么不同？" class="headerlink" title="进程和线程之间有什么不同？"></a>进程和线程之间有什么不同？</h3><p>一个进程是一个独立(self contained)的运行环境，它可以被看作一个程序或者一个应用。而线程是在进程中执行的一个任务。Java运行环境是一个包含了不同的类和程序的单一进程。线程可以v c被称为轻量级进程。线程需要较少的资源来创建和驻留在进程中，并且可以共享进程中的资源。</p><h3 id="多线程编程的好处是什么？"><a href="#多线程编程的好处是什么？" class="headerlink" title="多线程编程的好处是什么？"></a>多线程编程的好处是什么？</h3><p>在多线程程序中，多个线程被并发的执行以提高程序的效率，CPU不会因为某个线程需要等待资源而进入空闲状态。多个线程共享堆内存(heap memory)，因此创建多个线程去执行一些任务会比创建多个进程更好。举个例子，Servlets比CGI更好，是因为Servlets支持多线程而CGI不支持。</p><h3 id="用户线程和守护线程有什么区别？"><a href="#用户线程和守护线程有什么区别？" class="headerlink" title="用户线程和守护线程有什么区别？"></a>用户线程和守护线程有什么区别？</h3><p>当我们在Java程序中创建一个线程，它就被称为用户线程。一个守护线程是在v后台执行并且不会阻止JVM终止的线程。当没有用户线程在运行的时候，JVM关闭程序并且退出。一个守护线程创建的子线程依然是守护线程。</p><h3 id="我们如何创建一个线程？"><a href="#我们如何创建一个线程？" class="headerlink" title="我们如何创建一个线程？"></a>我们如何创建一个线程？</h3><p>有两种创建线程的方法：<br>一、实现<strong>Runnable</strong>接口，然后将它传递给Thread的构造函数，创建一个<strong>Thread</strong>对象；<br>二、直接继承<strong>Thread</strong>类。</p><h3 id="有哪些不同的线程生命周期？"><a href="#有哪些不同的线程生命周期？" class="headerlink" title="有哪些不同的线程生命周期？"></a>有哪些不同的线程生命周期？</h3><p>当我们在Java程序中新建一个线程时，它的状态是New。当我们调用线程的<code>start()</code>方法时，状态被改变为<strong>Runnable</strong>。线程调度器会为<strong>Runnable</strong>线程池中的线程分配CPU时间并且讲它们的状态改变为<code>Running</code>。其他的线程状态还有<code>Waiting</code>，<code>Blocked</code>和<code>Dead</code>。</p><h3 id="可以直接调用Thread类的run-方法么？"><a href="#可以直接调用Thread类的run-方法么？" class="headerlink" title="可以直接调用Thread类的run()方法么？"></a>可以直接调用Thread类的run()方法么？</h3><p>当然可以，但是如果我们调用了<strong>Thread</strong>的<code>run()</code>方法，它的行为就会和普通的方法一样，为了在新的线程中执行我们的代码，必须使用<strong>Thread</strong>的<code>start()</code>方法。</p><h3 id="如何让正在运行的线程暂停一段时间？"><a href="#如何让正在运行的线程暂停一段时间？" class="headerlink" title="如何让正在运行的线程暂停一段时间？"></a>如何让正在运行的线程暂停一段时间？</h3><p>我们可以使用Thread类的<code>Sleep()</code>方法让线程暂停一段时间。需要注意的是，这并不会让线程终止，一旦从休眠中唤醒线程，线程的状态将会被改变为<strong>Runnable</strong>，并且根据线程调度，它将得到执行。</p><h3 id="你对线程优先级的理解是什么？"><a href="#你对线程优先级的理解是什么？" class="headerlink" title="你对线程优先级的理解是什么？"></a>你对线程优先级的理解是什么？</h3><p>每一个线程都是有优先级的，一般来说，高优先级的线程在运行时会具有优先权，但这依赖于线程调度的实现，这个实现是和操作系统相关的(OS dependent)。我们可以定义线程的优先级，但是这并不能保证高优先级的线程会在低优先级的线程前执行。线程优先级是一个int变量(从1-10)，1代表最低优先级，10代表最高优先级。</p><h3 id="什么是线程调度器-Thread-Scheduler-和时间分片-Time-Slicing-？"><a href="#什么是线程调度器-Thread-Scheduler-和时间分片-Time-Slicing-？" class="headerlink" title="什么是线程调度器(Thread Scheduler)和时间分片(Time Slicing)？"></a>什么是线程调度器(Thread Scheduler)和时间分片(Time Slicing)？</h3><p>线程调度器是一个操作系统服务，它负责为<strong>Runnable</strong>状态的线程分配CPU时间。一旦我们创建一个线程并启动它，它的执行便依赖于线程调度器的实现。时间分片是指将可用的CPU时间分配给可用的<strong>Runnable</strong>线程的过程。分配CPU时间可以基于线程优先级或者线程等待的时间。线程调度并不受到Java虚拟机控制，所以由应用程序来控制它是更好的选择（也就是说不要让你的程序依赖于线程的优先级）。</p><h3 id="在多线程中，什么是上下文切换-context-switching-？"><a href="#在多线程中，什么是上下文切换-context-switching-？" class="headerlink" title="在多线程中，什么是上下文切换(context-switching)？"></a>在多线程中，什么是上下文切换(context-switching)？</h3><p>上下文切换是存储和恢复CPU状态的过程，它使得线程执行能够从中断点恢复执行。上下文切换是多任务操作系统和多线程环境的基本特征。</p><h3 id="你如何确保main-方法所在的线程是Java程序最后结束的线程？"><a href="#你如何确保main-方法所在的线程是Java程序最后结束的线程？" class="headerlink" title="你如何确保main()方法所在的线程是Java程序最后结束的线程？"></a>你如何确保main()方法所在的线程是Java程序最后结束的线程？</h3><p>我们可以使用<strong>Thread</strong>类的<code>joint()</code>方法来确保所有程序创建的线程在<code>main()</code>方法退出前结束。这里有一篇文章关于<strong>Thread</strong>类的<code>joint()</code>方法。</p><h3 id="线程之间是如何通信的？"><a href="#线程之间是如何通信的？" class="headerlink" title="线程之间是如何通信的？"></a>线程之间是如何通信的？</h3><p>当线程间是可以共享资源时，线程间通信是协调它们的重要的手段。<strong>Object</strong>类中<code>wait()</code>，<code>notify()</code>，<code>notifyAll()</code>方法可以用于线程间通信关于资源的锁的状态。</p><h3 id="为什么线程通信的方法wait-notify-和notifyAll-被定义在Object类里？"><a href="#为什么线程通信的方法wait-notify-和notifyAll-被定义在Object类里？" class="headerlink" title="为什么线程通信的方法wait(), notify()和notifyAll()被定义在Object类里？"></a>为什么线程通信的方法wait(), notify()和notifyAll()被定义在Object类里？</h3><p>Java的每个对象中都有一个锁(monitor，也可以成为监视器) 并且<code>wait()</code>，<code>notify()</code>等方法用于等待对象的锁或者通知其他线程对象的监视器可用。在Java的线程中并没有可供任何对象使用的锁和同步器。这就是为什么这些方法是<strong>Object</strong>类的一部分，这样Java的每一个类都有用于线程间通信的基本方法。</p><h3 id="为什么wait-notify-和notifyAll-必须在同步方法或者同步块中被调用？"><a href="#为什么wait-notify-和notifyAll-必须在同步方法或者同步块中被调用？" class="headerlink" title="为什么wait(), notify()和notifyAll()必须在同步方法或者同步块中被调用？"></a>为什么wait(), notify()和notifyAll()必须在同步方法或者同步块中被调用？</h3><p>当一个线程需要调用对象的<code>wait()</code>方法的时候，这个线程必须拥有该对象的锁，接着它就会释放这个对象锁并进入等待状态直到其他线程调用这个对象上的<code>notify()</code>方法。同样的，当一个线程需要调用对象的<code>notify()</code>方法时，它会释放这个对象的锁，以便其他在等待的线程就可以得到这个对象锁。由于所有的这些方法都需要线程持有对象的锁，这样就只能通过同步来实现，所以他们只能在同步方法或者同步块中被调用。</p><h3 id="为什么Thread类的sleep-和yield-方法是静态的？"><a href="#为什么Thread类的sleep-和yield-方法是静态的？" class="headerlink" title="为什么Thread类的sleep()和yield()方法是静态的？"></a>为什么Thread类的sleep()和yield()方法是静态的？</h3><p><strong>Thread</strong>类的<code>sleep()</code>和<code>yield()</code>方法将在当前正在执行的线程上运行。所以在其他处于等待状态的线程上调用这些方法是没有意义的。这就是为什么这些方法是静态的。它们可以在当前正在执行的线程中工作，并避免程序员错误的认为可以在其他非运行线程调用这些方法。</p><h3 id="如何确保线程安全？"><a href="#如何确保线程安全？" class="headerlink" title="如何确保线程安全？"></a>如何确保线程安全？</h3><p>在Java中可以有很多方法来保证线程安全——同步，使用原子类(atomic concurrent classes)，实现并发锁，使用<strong>volatile</strong>关键字，使用不变类和线程安全类。</p><h3 id="volatile关键字在Java中有什么作用？"><a href="#volatile关键字在Java中有什么作用？" class="headerlink" title="volatile关键字在Java中有什么作用？"></a>volatile关键字在Java中有什么作用？</h3><p>当我们使用volatile关键字去修饰变量的时候，所以线程都会直接读取该变量并且不缓存它。这就确保了线程读取到的变量是同内存中是一致的。</p><h3 id="同步方法和同步块，哪个是更好的选择？"><a href="#同步方法和同步块，哪个是更好的选择？" class="headerlink" title="同步方法和同步块，哪个是更好的选择？"></a>同步方法和同步块，哪个是更好的选择？</h3><p>同步块是更好的选择，因为它不会锁住整个对象（当然你也可以让它锁住整个对象）。同步方法会锁住整个对象，哪怕这个类中有多个不相关联的同步块，这通常会导致他们停止执行并需要等待获得这个对象上的锁。</p><h3 id="如何创建守护线程？"><a href="#如何创建守护线程？" class="headerlink" title="如何创建守护线程？"></a>如何创建守护线程？</h3><p>使用<strong>Thread</strong>类的<code>setDaemon(true)</code>方法可以将线程设置为守护线程，需要注意的是，需要在调用<code>start()</code>方法前调用这个方法，否则会抛出<strong>IllegalThreadStateException</strong>异常。</p><h3 id="什么是ThreadLocal"><a href="#什么是ThreadLocal" class="headerlink" title="什么是ThreadLocal?"></a>什么是ThreadLocal?</h3><p><strong>ThreadLocal</strong>用于创建线程的本地变量，我们知道一个对象的所有线程会共享它的全局变量，所以这些变量不是线程安全的，我们可以使用同步技术。但是当我们不想使用同步的时候，我们可以选择<strong>ThreadLocal</strong>变量。<br>每个线程都会拥有他们自己的<strong>Thread</strong>变量，它们可以使用<code>get()</code>，<code>set()</code>方法去获取他们的默认值或者在线程内部改变他们的值。<strong>ThreadLocal</strong>实例通常是希望它们同线程状态关联起来是<strong>private static</strong>属性。</p><h3 id="什么是Thread-Group？为什么建议使用它？"><a href="#什么是Thread-Group？为什么建议使用它？" class="headerlink" title="什么是Thread Group？为什么建议使用它？"></a>什么是Thread Group？为什么建议使用它？</h3><p><strong>ThreadGroup</strong>是一个类，它的目的是提供关于线程组的信息。<br><strong>ThreadGroup API</strong>比较薄弱，它并没有比<strong>Thread</strong>提供了更多的功能。它有两个主要的功能：一是获取线程组中处于活跃状态线程的列表；二是设置为线程设置未捕获异常处理器(ncaught exception handler)。但在Java 1.5中Thread类也添加了<code>setUncaughtExceptionHandler(UncaughtExceptionHandler eh)</code>方法，所以<strong>ThreadGroup</strong>是已经过时的，不建议继续使用。<br><code>1t1.setUncaughtExceptionHandler(newUncaughtExceptionHandler(){23@Override4publicvoiduncaughtException(Thread t, Throwable e) {5System.out.println(&quot;exception occured:&quot;+e.getMessage());6}78});</code></p><h3 id="什么是Java线程转储-Thread-Dump-，如何得到它？"><a href="#什么是Java线程转储-Thread-Dump-，如何得到它？" class="headerlink" title="什么是Java线程转储(Thread Dump)，如何得到它？"></a>什么是Java线程转储(Thread Dump)，如何得到它？</h3><p>线程转储是一个JVM活动线程的列表，它对于分析系统瓶颈和死锁非常有用。有很多方法可以获取线程转储——使用<code>Profiler，Kill -3</code>命令，<strong>jstack</strong>工具等等。我更喜欢jstack工具，因为它容易使用并且是JDK自带的。由于它是一个基于终端的工具，所以我们可以编写一些脚本去定时的产生线程转储以待分析。</p><h3 id="什么是死锁-Deadlock-？如何分析和避免死锁？"><a href="#什么是死锁-Deadlock-？如何分析和避免死锁？" class="headerlink" title="什么是死锁(Deadlock)？如何分析和避免死锁？"></a>什么是死锁(Deadlock)？如何分析和避免死锁？</h3><p>死锁是指两个以上的线程永远阻塞的情况，这种情况产生至少需要两个以上的线程和两个以上的资源。<br>分析死锁，我们需要查看Java应用程序的线程转储。我们需要找出那些状态为<strong>BLOCKED</strong>的线程和他们等待的资源。每个资源都有一个唯一的id，用这个id我们可以找出哪些线程已经拥有了它的对象锁。<br>避免嵌套锁，只在需要的地方使用锁和避免无限期等待是避免死锁的通常办法。</p><h3 id="什么是Java-Timer类？如何创建一个有特定时间间隔的任务？"><a href="#什么是Java-Timer类？如何创建一个有特定时间间隔的任务？" class="headerlink" title="什么是Java Timer类？如何创建一个有特定时间间隔的任务？"></a>什么是Java Timer类？如何创建一个有特定时间间隔的任务？</h3><p><strong>java.util.Timer</strong>是一个工具类，可以用于安排一个线程在未来的某个特定时间执行。<strong>Timer</strong>类可以用安排一次性任务或者周期任务。<br><strong>java.util.TimerTask</strong>是一个实现了<strong>Runnable</strong>接口的抽象类，我们需要去继承这个类来创建我们自己的定时任务并使用<strong>Timer</strong>去安排它的执行。</p><h3 id="什么是线程池？如何创建一个Java线程池？"><a href="#什么是线程池？如何创建一个Java线程池？" class="headerlink" title="什么是线程池？如何创建一个Java线程池？"></a>什么是线程池？如何创建一个Java线程池？</h3><p>一个线程池管理了一组工作线程，同时它还包括了一个用于放置等待执行的任务的队列。<br><strong>java.util.concurrent.Executors</strong>提供了一个<strong>java.util.concurrent.Executor</strong>接口的实现用于创建线程池。</p><hr><hr><h2 id="并发面试问题"><a href="#并发面试问题" class="headerlink" title="并发面试问题"></a>并发面试问题</h2><h3 id="什么是原子操作？在Java-Concurrency-API中有哪些原子类-atomic-classes-？"><a href="#什么是原子操作？在Java-Concurrency-API中有哪些原子类-atomic-classes-？" class="headerlink" title="什么是原子操作？在Java Concurrency API中有哪些原子类(atomic classes)？"></a>什么是原子操作？在Java Concurrency API中有哪些原子类(atomic classes)？</h3><p>原子操作是指一个不受其他操作影响的操作任务单元。原子操作是在多线程环境下避免数据不一致必须的手段。<br><code>int++</code>并不是一个原子操作，所以当一个线程读取它的值并加1时，另外一个线程有可能会读到之前的值，这就会引发错误。<br>为了解决这个问题，必须保证增加操作是原子的，在JDK1.5之前我们可以使用同步技术来做到这一点。到JDK1.5，<strong>java.util.concurrent.atomic</strong>包提供了<code>int</code>和<code>long</code>类型的装类，它们可以自动的保证对于他们的操作是原子的并且不需要使用同步。</p><h3 id="Java-Concurrency-API中的Lock接口-Lock-interface-是什么？对比同步它有什么优势？"><a href="#Java-Concurrency-API中的Lock接口-Lock-interface-是什么？对比同步它有什么优势？" class="headerlink" title="Java Concurrency API中的Lock接口(Lock interface)是什么？对比同步它有什么优势？"></a>Java Concurrency API中的Lock接口(Lock interface)是什么？对比同步它有什么优势？</h3><p><strong>Lock</strong>接口比同步方法和同步块提供了更具扩展性的锁操作。他们允许更灵活的结构，可以具有完全不同的性质，并且可以支持多个相关类的条件对象。<br>它的优势有：<br>可以使锁更公平;<br>可以使线程在等待锁的时候响应中断;<br>可以让线程尝试获取锁，并在无法获取锁的时候立即返回或者等待一段时间;<br>可以在不同的范围，以不同的顺序获取和释放锁。</p><h3 id="什么是Executors框架？"><a href="#什么是Executors框架？" class="headerlink" title="什么是Executors框架？"></a>什么是Executors框架？</h3><p><strong>Executor</strong>框架同<strong>java.util.concurrent.Executor</strong>接口在Java 5中被引入。<strong>Executor</strong>框架是一个根据一组执行策略调用，调度，执行和控制的异步任务的框架。<br>无限制的创建线程会引起应用程序内存溢出。所以创建一个线程池是个更好的的解决方案，因为可以限制线程的数量并且可以回收再利用这些线程。</p><h3 id="什么是阻塞队列？如何使用阻塞队列来实现生产者-消费者模型？"><a href="#什么是阻塞队列？如何使用阻塞队列来实现生产者-消费者模型？" class="headerlink" title="什么是阻塞队列？如何使用阻塞队列来实现生产者-消费者模型？"></a>什么是阻塞队列？如何使用阻塞队列来实现生产者-消费者模型？</h3><p><strong>java.util.concurrent.BlockingQueue</strong>的特性是：当队列是空的时，从队列中获取或删除元素的操作将会被阻塞，或者当队列是满时，往队列里添加元素的操作会被阻塞。<br>阻塞队列不接受空值，当你尝试向队列中添加空值的时候，它会抛出<strong>NullPointerException</strong>。<br>阻塞队列的实现都是线程安全的，所有的查询方法都是原子的并且使用了内部锁或者其他形式的并发控制。<br><strong>BlockingQueue</strong>接口是<strong>collections</strong>框架的一部分，它主要用于实现生产者-消费者问题。</p><h3 id="什么是Callable和Future"><a href="#什么是Callable和Future" class="headerlink" title="什么是Callable和Future?"></a>什么是Callable和Future?</h3><p>Java 5在<strong>concurrency</strong>包中引入了<strong>java.util.concurrent.Callable</strong>接口，它和<strong>Runnable</strong>接口很相似，但它可以返回一个对象或者抛出一个异常。<br><strong>Callable</strong>接口使用泛型去定义它的返回类型。<strong>Executors</strong>类提供了一些有用的方法去在线程池中执行<strong>Callable</strong>内的任务。由于<strong>Callable</strong>任务是并行的，我们必须等待它返回的结果。<strong>java.util.concurrent.Future</strong>对象为我们解决了这个问题。在线程池提交<strong>Callable</strong>任务后返回了一个<strong>Future</strong>对象，使用它我们可以知道<strong>Callable</strong>任务的状态和得到<strong>Callable</strong>返回的执行结果。<strong>Future</strong>提供了<code>get()</code>方法让我们可以等待<strong>Callable</strong>结束并获取它的执行结果。</p><h3 id="什么是FutureTask-v"><a href="#什么是FutureTask-v" class="headerlink" title="什么是FutureTask?v"></a>什么是FutureTask?v</h3><p><strong>FutureTask</strong>是<strong>Future</strong>的一个基础实现，我们可以将它同<strong>Executors</strong>使用处理异步任务。通常我们不需要使用<strong>FutureTask</strong>类，单当我们打算重写<strong>Future</strong>接口的一些方法并保持原来基础的实现是，它就变得非常有用。我们可以仅仅继承于它并重写我们需要的方法。</p><h3 id="什么是并发容器的实现？"><a href="#什么是并发容器的实现？" class="headerlink" title="什么是并发容器的实现？"></a>什么是并发容器的实现？</h3><p>Java集合类都是快速失败的，这就意味着当集合被改变且一个线程在使用迭代器遍历集合的时候，迭代器的<code>next()</code>方法将抛出<strong>ConcurrentModificationException</strong>异常。<br>并发容器支持并发的遍历和并发的更新。<br>主要的类有<strong>ConcurrentHashMap</strong>, <strong>CopyOnWriteArrayList</strong>和<strong>CopyOnWriteArraySet</strong>。</p><h3 id="Executors类是什么？"><a href="#Executors类是什么？" class="headerlink" title="Executors类是什么？"></a>Executors类是什么？</h3><p><strong>Executors</strong>为<strong>Executor</strong>，<strong>ExecutorService</strong>，<strong>ScheduledExecutorService</strong>，<strong>ThreadFactory</strong>和<strong>Callable</strong>类提供了一些工具方法。<br><strong>Executors</strong>可以用于方便的创建线程池。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> 面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>String学习笔记</title>
      <link href="/post/String%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html"/>
      <url>/post/String%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html</url>
      
        <content type="html"><![CDATA[<blockquote class="blockquote-center">String相关</blockquote><h2 id="String常用API"><a href="#String常用API" class="headerlink" title="String常用API"></a>String常用API</h2><h3 id="1-返回给定位置的代码单元。-偏底层代码单元，一般不使用"><a href="#1-返回给定位置的代码单元。-偏底层代码单元，一般不使用" class="headerlink" title="1.返回给定位置的代码单元。(偏底层代码单元，一般不使用)"></a>1.返回给定位置的代码单元。(偏底层代码单元，一般不使用)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">char charAt(int index)</span><br></pre></td></tr></table></figure><h3 id="2-返回从给定位置开始的码点。"><a href="#2-返回从给定位置开始的码点。" class="headerlink" title="2.返回从给定位置开始的码点。"></a>2.返回从给定位置开始的码点。</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int codePointAt(int index)</span><br></pre></td></tr></table></figure><h3 id="3-按照字典顺序，如果字符串位于other之前，返回一个负数；如果字符串位于other之后，返回一个正数；如果两个字符串相等，返回0"><a href="#3-按照字典顺序，如果字符串位于other之前，返回一个负数；如果字符串位于other之后，返回一个正数；如果两个字符串相等，返回0" class="headerlink" title="3.按照字典顺序，如果字符串位于other之前，返回一个负数；如果字符串位于other之后，返回一个正数；如果两个字符串相等，返回0."></a>3.按照字典顺序，如果字符串位于other之前，返回一个负数；如果字符串位于other之后，返回一个正数；如果两个字符串相等，返回0.</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int compareTo(String other)</span><br></pre></td></tr></table></figure><h3 id="4-将这个字符串的码点作为一个流返回。调用toArray将它们放在一个数组中。"><a href="#4-将这个字符串的码点作为一个流返回。调用toArray将它们放在一个数组中。" class="headerlink" title="4.将这个字符串的码点作为一个流返回。调用toArray将它们放在一个数组中。"></a>4.将这个字符串的码点作为一个流返回。调用toArray将它们放在一个数组中。</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IntStream codePoints()</span><br></pre></td></tr></table></figure><h3 id="5-用数组中从offset开始的count个码点构造一个字符串。"><a href="#5-用数组中从offset开始的count个码点构造一个字符串。" class="headerlink" title="5.用数组中从offset开始的count个码点构造一个字符串。"></a>5.用数组中从offset开始的count个码点构造一个字符串。</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new String(int[] codePoints, int offset, int count)</span><br></pre></td></tr></table></figure><h3 id="6-如果字符串与other相等，返回true。"><a href="#6-如果字符串与other相等，返回true。" class="headerlink" title="6.如果字符串与other相等，返回true。"></a>6.如果字符串与other相等，返回true。</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">boolean equals(Object other)</span><br></pre></td></tr></table></figure><h3 id="7-如果字符串与other相等-忽略大小写-，返回true。"><a href="#7-如果字符串与other相等-忽略大小写-，返回true。" class="headerlink" title="7.如果字符串与other相等(忽略大小写)，返回true。"></a>7.如果字符串与other相等(忽略大小写)，返回true。</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">boolean equalsIgnoreCase(String other)</span><br></pre></td></tr></table></figure><h3 id="8-如果字符串以suffix开头或结尾，返回true。"><a href="#8-如果字符串以suffix开头或结尾，返回true。" class="headerlink" title="8.如果字符串以suffix开头或结尾，返回true。"></a>8.如果字符串以suffix开头或结尾，返回true。</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">boolean startsWith(String prefix)</span><br><span class="line">boolean endsWith(String suffix)</span><br></pre></td></tr></table></figure><h3 id="9-返回与字符串str或代码点cp匹配的第一个子串的开始位置。这个位置从索引0或fromIndex开始计算。如果在原始串中不存在str，返回-1。"><a href="#9-返回与字符串str或代码点cp匹配的第一个子串的开始位置。这个位置从索引0或fromIndex开始计算。如果在原始串中不存在str，返回-1。" class="headerlink" title="9.返回与字符串str或代码点cp匹配的第一个子串的开始位置。这个位置从索引0或fromIndex开始计算。如果在原始串中不存在str，返回-1。"></a>9.返回与字符串str或代码点cp匹配的第一个子串的开始位置。这个位置从索引0或fromIndex开始计算。如果在原始串中不存在str，返回-1。</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int indexOf(String str)</span><br><span class="line">int indexOf(String str, int fromIndex)</span><br><span class="line">int indexOf(int cp)</span><br><span class="line">int indexOf(int cp, int fromIndex)</span><br></pre></td></tr></table></figure><h3 id="10-返回与字符串str或代码点cp匹配的最后一个子串的开始位置。这个位置从原始串尾端或fromIndex开始计算。"><a href="#10-返回与字符串str或代码点cp匹配的最后一个子串的开始位置。这个位置从原始串尾端或fromIndex开始计算。" class="headerlink" title="10.返回与字符串str或代码点cp匹配的最后一个子串的开始位置。这个位置从原始串尾端或fromIndex开始计算。"></a>10.返回与字符串str或代码点cp匹配的最后一个子串的开始位置。这个位置从原始串尾端或fromIndex开始计算。</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int lastIndexOf(String str)</span><br><span class="line">int lastIndexOf(String str, int fromIndex)</span><br><span class="line">int lastIndexOf(int cp)</span><br><span class="line">int lastIndexOf(int cp, int fromIndex)</span><br></pre></td></tr></table></figure><h3 id="11-返回字符串的长度。"><a href="#11-返回字符串的长度。" class="headerlink" title="11.返回字符串的长度。"></a>11.返回字符串的长度。</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int length()</span><br></pre></td></tr></table></figure><h3 id="12-返回一个新字符串。这个字符串用newString代替原始字符串中所有的oldString。可以用Stirng或StringBuilder对象作为CharSequence参数。"><a href="#12-返回一个新字符串。这个字符串用newString代替原始字符串中所有的oldString。可以用Stirng或StringBuilder对象作为CharSequence参数。" class="headerlink" title="12.返回一个新字符串。这个字符串用newString代替原始字符串中所有的oldString。可以用Stirng或StringBuilder对象作为CharSequence参数。"></a>12.返回一个新字符串。这个字符串用newString代替原始字符串中所有的oldString。可以用Stirng或StringBuilder对象作为CharSequence参数。</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String replace(CharSequence oldString, charSequence newString)</span><br></pre></td></tr></table></figure><h3 id="13-返回一个新字符串。这个字符串包含原始字符串中从从beginIndex到串尾或endIndex-1的所有代码单元。"><a href="#13-返回一个新字符串。这个字符串包含原始字符串中从从beginIndex到串尾或endIndex-1的所有代码单元。" class="headerlink" title="13.返回一个新字符串。这个字符串包含原始字符串中从从beginIndex到串尾或endIndex-1的所有代码单元。"></a>13.返回一个新字符串。这个字符串包含原始字符串中从从beginIndex到串尾或endIndex-1的所有代码单元。</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String substing(int beginIndex)</span><br><span class="line">String substing(int beginIndex, int endIndex)</span><br></pre></td></tr></table></figure><h3 id="14-返回一个新字符串。这个字符串将原始字符串中的大写字母改成小写字母。"><a href="#14-返回一个新字符串。这个字符串将原始字符串中的大写字母改成小写字母。" class="headerlink" title="14.返回一个新字符串。这个字符串将原始字符串中的大写字母改成小写字母。"></a>14.返回一个新字符串。这个字符串将原始字符串中的大写字母改成小写字母。</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String toLowerCase()</span><br></pre></td></tr></table></figure><h3 id="15-返回一个新字符串。这个字符串将原始字符串中的小写字母改成大写字母。"><a href="#15-返回一个新字符串。这个字符串将原始字符串中的小写字母改成大写字母。" class="headerlink" title="15.返回一个新字符串。这个字符串将原始字符串中的小写字母改成大写字母。"></a>15.返回一个新字符串。这个字符串将原始字符串中的小写字母改成大写字母。</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String toUpperCase()</span><br></pre></td></tr></table></figure><h3 id="16-返回一个新字符串。这个字符串将删除原始字符串头部和尾部的空格。"><a href="#16-返回一个新字符串。这个字符串将删除原始字符串头部和尾部的空格。" class="headerlink" title="16.返回一个新字符串。这个字符串将删除原始字符串头部和尾部的空格。"></a>16.返回一个新字符串。这个字符串将删除原始字符串头部和尾部的空格。</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String trim()</span><br></pre></td></tr></table></figure><h3 id="17-返回一个新字符串。用给定的定界符连接所有元素。"><a href="#17-返回一个新字符串。用给定的定界符连接所有元素。" class="headerlink" title="17.返回一个新字符串。用给定的定界符连接所有元素。"></a>17.返回一个新字符串。用给定的定界符连接所有元素。</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String join(charSequence delimiter, charSequence... elements)</span><br></pre></td></tr></table></figure><h3 id="18-返回从startIndex代码点开始，位移cpCount后的码点索引。"><a href="#18-返回从startIndex代码点开始，位移cpCount后的码点索引。" class="headerlink" title="18.返回从startIndex代码点开始，位移cpCount后的码点索引。"></a>18.返回从startIndex代码点开始，位移cpCount后的码点索引。</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int offsetByCodePoints(int startIndex, int cpCount)</span><br></pre></td></tr></table></figure><h3 id="19-返回startIndex和endIndex-1之间的代码点数量。没有配成对的代用字符将计入代码点。"><a href="#19-返回startIndex和endIndex-1之间的代码点数量。没有配成对的代用字符将计入代码点。" class="headerlink" title="19.返回startIndex和endIndex-1之间的代码点数量。没有配成对的代用字符将计入代码点。"></a>19.返回startIndex和endIndex-1之间的代码点数量。没有配成对的代用字符将计入代码点。</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int codePointCount(int startIndex, int endIndex)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>英语语法基础-冠词</title>
      <link href="/post/%E8%8B%B1%E8%AF%AD%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80-%E5%86%A0%E8%AF%8D.html"/>
      <url>/post/%E8%8B%B1%E8%AF%AD%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80-%E5%86%A0%E8%AF%8D.html</url>
      
        <content type="html"><![CDATA[<blockquote class="blockquote-center">冠词的学习笔记</blockquote><h2 id="一-冠词"><a href="#一-冠词" class="headerlink" title="一.冠词"></a>一.冠词</h2><ul><li>概念：冠词是置于名词前并限定名词的意义的虚词。</li><li>定冠词：<code>the</code>，主要特点“确指”或“特指”。</li><li>不定冠词：<code>a/an</code>，主要特点“不确定”或“泛指”。</li><li>零冠词：名词前不使用冠词，</li></ul><h2 id="二-a与an的用法区别"><a href="#二-a与an的用法区别" class="headerlink" title="二.a与an的用法区别"></a>二.a与an的用法区别</h2><h3 id="1-基本区别：a用于辅音前，an用于元音前。"><a href="#1-基本区别：a用于辅音前，an用于元音前。" class="headerlink" title="1. 基本区别：a用于辅音前，an用于元音前。"></a>1. 基本区别：a用于辅音前，an用于元音前。</h3><p><code>a</code>的例子：<code>a book</code>、<code>a house</code>、<code>a student</code>、<code>a school</code><br><code>an</code>的例子：<code>an egg</code>、<code>an apple</code>、<code>an idea</code>、<code>an object</code>、<code>an ugly thing</code></p><h3 id="2-易错点"><a href="#2-易错点" class="headerlink" title="2. 易错点"></a>2. 易错点</h3><ol><li>以辅音字母开头，但<strong>读音以元音开头</strong>的单词，用<code>an</code>。如：<br><code>hour</code>、<code>honest</code>、<code>honor</code></li><li>以元音字母开头，但<strong>读音以辅音开头</strong>的单词，用<code>a</code>。如：<br><code>useful</code>、<code>university</code>、<code>usual</code>、<code>united</code>、<code>one-eyed</code>、<code>one-way</code>、<code>European</code></li><li>对于数字、字母以及由单词首字母构成的缩略词，需要根据读音来确定用<code>a/an</code>。例：<ul><li><code>He has an 11-year-old son.</code><br>他有一个11岁的儿子。</li><li><code>Our son sent us an SOS for some more money.</code><br>我们的儿子给我们发来了再要点钱的求救信号。</li></ul></li></ol><h2 id="三-冠词在句中的位置"><a href="#三-冠词在句中的位置" class="headerlink" title="三.冠词在句中的位置"></a>三.冠词在句中的位置</h2><h3 id="1-通常位置："><a href="#1-通常位置：" class="headerlink" title="1. 通常位置："></a>1. 通常位置：</h3><ol><li>冠词一般放在单数可数名词之前，如：<br><code>a man</code>、<code>the man</code>；</li><li>若名词由其他定语，不定冠词应放在定语之前，如：<br><code>a good man</code>、<code>the good man</code></li></ol><h3 id="2-特殊位置："><a href="#2-特殊位置：" class="headerlink" title="2. 特殊位置："></a>2. 特殊位置：</h3><ol><li><p>单数可数名词被<code>such</code>，<code>many</code>，<code>half</code>，<code>what</code>等修饰时，不定冠词应<strong>置于其后</strong>。如：</p><ul><li><code>He arrived half an hour ago.</code><br>他是半小时前到达的。</li><li><code>He couldn&#39;t afford to pay such a price.</code><br>他出不起这样的价钱。</li></ul></li><li><p>单数可数名词前作定语的形容词被<code>as</code>，<code>so</code>，<code>how</code>，<code>too</code>修饰时，通常采用<code>“as/ so/ how/ too + 形容词 + a/ an + 名词”</code>这样的词序。如：</p><ul><li><code>He didn&#39;t know how great a mistake he had made.</code><br>他不知道他自己犯了一个很大的错误。</li><li><code>It is too difficult a job for me to finish in so short a time.</code><br>在如此短的时间内完成工作对我来说太难了。</li></ul></li><li><p>当定冠词与<code>all</code>，<code>both</code>，<code>half</code>表<strong>倍数</strong>的<code>double</code>，<code>twice</code>，<code>three times</code>等<strong>分数词</strong>一起修饰名词时，定冠词<strong>应放在它们之后</strong>。如：</p><ul><li><code>Turn off all the lights before you go to bed.</code><br>睡觉前把灯都关了。</li><li><code>Everything was almost double the normal price.</code><br>样样东西几乎都是平时价格的两倍。</li></ul></li></ol><h2 id="四-不定冠词的用法"><a href="#四-不定冠词的用法" class="headerlink" title="四.不定冠词的用法"></a>四.不定冠词的用法</h2><ol><li><p>不定冠词用在<strong>单数可数名词前</strong>表示<strong>某一个</strong>。如：</p><ul><li><code>There is a policeman at the door.</code><br>门口有个警察。</li></ul></li><li><p>不定冠词用在<strong>单数可数名词之前</strong>，表示<strong>任何，每个</strong>。如：</p><ul><li><code>A car must be insured.</code><br>汽车一定要上保险。</li><li><code>A soldier must obey orders.</code><br>军人必须服从命令。</li></ul></li><li><p>不定冠词用于<strong>头一次出现的单数名词之前</strong>。如：</p><ul><li><code>There is a box in the room. The box is heavy.</code><br>房间里有个箱子。这个箱子很重。</li></ul></li><li><p>不定冠词<strong>和名词连用作表语或同位语</strong>，主要<strong>说明某个人或东西所属类别</strong>。如：</p><ul><li><code>She is a teacher.</code><br>她是个老师。</li><li><code>We all thought him a suitable person for the job.</code><br>我们都认为他是适合做这个项目的人。</li></ul></li><li><p>定冠词用在<strong>价格、速度、比率等短语</strong>中。如：</p><ul><li><code>six kilometers an hour</code><br>每小时60公里</li><li><code>3 times a day</code><br>每天三次</li><li><code>I go to school five days a week.</code><br>我一周上五天课。</li></ul></li><li><p>不定冠词用在<strong>专有名词前</strong>。如：</p><ul><li><code>He wants to buy a Kodak.</code><br>他想买架柯达相机。</li></ul></li><li><p>不定冠词用于<strong>某些固定短语</strong>中。如：</p><ul><li><code>have a try</code> 试一下   </li><li><code>take a break</code> 休息一下  </li><li><code>have a good time</code> 玩得痛快</li><li><code>make a living</code> 谋生   </li><li><code>as a matter of fact</code> 事实上  </li><li><code>in a word</code> 总而言之</li></ul></li></ol><h2 id="五-定冠词的用法"><a href="#五-定冠词的用法" class="headerlink" title="五.定冠词的用法"></a>五.定冠词的用法</h2><ol><li><p>定冠词和<strong>名词连用</strong>，表示<strong>某个或某些特定的人或东西</strong>。如：</p><ul><li><code>Mother carved the meat into slices.</code><br>妈妈把肉切成了片。</li></ul></li><li><p>定冠词用于<strong>可数名词前</strong>，表示<strong>一类人或东西</strong>。如：</p><ul><li><code>The horse is a useful animal.</code><br>马是一种有用的动物。</li></ul></li><li><p>定冠词用于<strong>第二次出现的名词之前</strong>。如：</p><ul><li><code>I got a letter yesterday. The letter was sent by e-mail.</code><br>我昨天接到了一封信。那信是电子邮件。</li></ul></li><li><p>定冠词用于<strong>有词组或者定语从句修饰的名词前</strong>。如：</p><ul><li><code>He is investigating the cause of the fire.</code><br>他正在调查这场大火的原因。</li></ul></li><li><p>定冠词用于<strong>某些名词或者形容词前</strong>，表示<strong>一类人，一个民族，阶级或阶层</strong>。如：</p><ul><li><code>the chinese</code> 中国人  </li><li><code>the rich</code> 富人</li><li><code>the dead</code> 死者          </li><li><code>the deaf</code> 聋人</li></ul></li><li><p>定冠词用于<strong>指说话双方都知道的人或事</strong>。如：</p><ul><li><code>Please close the door.</code><br>请把门关上。</li></ul></li><li><p>定冠词用于<strong>世界上独一无二的事物前</strong>。如：</p><ul><li><code>the sun</code> 太阳    </li><li><code>the earth</code> 地球    </li><li><code>the world</code> 世界  </li></ul></li><li><p>定冠词用于<strong>序数词前表示顺序</strong>。如：</p><ul><li><code>the third group</code> 第三组</li></ul></li><li><p>定冠词用于<strong>形容词和副词的最高级前面</strong>。如：</p><ul><li><code>This is the most intersting book I have ever read.</code><br>这是我所读过的书中最有趣的一本。</li></ul></li><li><p>定冠词在<strong>play后和乐器连用</strong>。如：</p><ul><li><code>play the piano</code> 弹钢琴       </li><li><code>play the flute</code> 吹长笛</li></ul></li><li>定冠词与<strong>姓氏的复数，形式连用</strong>，表示<strong>一家人</strong>。如：<ul><li><code>The Blacks came to China in 1994.</code><br>布莱克一家是1994年来中国的。</li></ul></li><li>定冠词的<strong>其他</strong>用法<ul><li><code>the Changjiang River</code> 长江 </li><li><code>the Red Sea</code> 红海（用于表示江河海洋的名词前）</li><li><code>the Taiwan Straits</code> 台湾海峡 </li><li><code>the Gulf of Mexico</code> 墨西哥湾（用于表示海峡海湾的名词前）</li><li><code>the Alps</code> 阿尔卑斯山     </li><li><code>the Sahara Desert</code> 撒哈拉沙漠（用于山脉沙漠的名词前）</li><li><code>the People’s Republic of China</code> 中华人民共和国（用于国家名称）</li><li><code>the National Gallery</code> 国家美术馆   </li><li><code>the Military Museum</code> 军事博物馆（用于公共建筑名前）</li><li><code>the State Council</code> 国务院    </li><li><code>the Senate</code> 参议院 </li><li><code>the House of Representatives</code> 众议院（用于机关、团体名词前）</li><li><code>the Geneva Agreement</code> 日内瓦协议  </li><li><code>the Washington Post</code> 华盛顿邮报（用于报刊、条约之前）</li></ul></li></ol><h2 id="六-零冠词的用法"><a href="#六-零冠词的用法" class="headerlink" title="六.零冠词的用法"></a>六.零冠词的用法</h2><ol><li><p>在专有名词和不可数名词前。如：</p><ul><li><code>Class two</code>  二班</li><li><code>Tian’an men square</code>  天安门广场</li><li><code>Water</code>  水</li></ul></li><li><p>可数名词前已有作定语的物主代词(my，your，his，her等)、指示代词(this/these，that/those)、不定代词(some，any等)及所有格限制时。如：</p><ul><li><code>my book</code>(正)，<code>my the book</code>(误)</li></ul></li><li><p>复数名词表示一类人或事物时。如：</p><ul><li><code>They are teachers.</code><br>他们是老师。</li><li><code>Tigers like meat.</code><br>老虎喜欢吃肉。</li></ul></li><li><p>在<strong>星期，月份，季节，节日</strong>前。如：</p><ul><li><code>on sunday</code>   在周日</li><li><code>in march</code>   在三月</li><li><code>in spring</code>   在春天</li><li><code>on women’s day</code>  在妇女节</li><li>特例：如果月份，季节等<strong>被一个限定性定语修饰时</strong>，则要加定冠词。<ul><li><code>He joined the army in the spring of 1982.</code><br>他在1982年春季参军。</li></ul></li></ul></li><li><p>在<strong>称呼语</strong>或表示<strong>头衔</strong>的名词前。如：</p><ul><li><code>tom</code> 汤姆</li><li><code>mum</code> 妈妈</li></ul></li><li><p>在<strong>学科名称、三餐饭和球类运动名称</strong>前。如：</p><ul><li><p><code>I have lunch at school every day.</code><br>我每天都在学校吃午饭。</p></li><li><p>特例：当football，basketball指具体的某个球时，其前可以用冠词。</p><ul><li><code>I can see a football.</code><br>我可以看到一只足球。</li><li><code>Where&#39;s the football？</code><br>那只足球在哪儿？(指足球，并非“球类运动”)</li></ul></li></ul></li><li><p>在表<strong>特定的公园，街道，车站，桥，学校</strong>等之前。如：</p><ul><li><code>No.25 middle school</code><br>25号中学</li></ul></li><li><p>某些固定词组中不用冠词。</p><ol><li><p>与<code>by</code>连用的<strong>交通工具名称</strong>前：</p><ul><li><code>by bus</code>   乘公共汽车</li><li><code>by car</code>   乘汽车</li><li><code>by bike</code>   骑/坐自行车</li><li><code>by train</code>  乘火车</li><li><code>by air/plane</code>  乘飞机</li><li><code>by sea/ship</code>  乘船</li><li>但<code>take a bus</code>，<code>in a boat</code>，<code>on the bike</code>前需用冠词</li></ul></li><li><p><strong>名词</strong>词组：</p><ul><li><code>day and night</code>   日日夜夜</li><li><code>brother and sister</code>  兄弟姐妹</li><li><code>hour after hour</code>   时时刻刻</li><li><code>here and there</code>   到处</li></ul></li><li><p><strong>介词</strong>词组：</p><ul><li><code>at home</code> 在家</li><li><code>in surprise</code> 惊奇地</li><li><code>at noon</code> 在中午</li><li><code>on foot</code> 步行</li><li><code>at night</code> 在晚上</li><li><code>on duty</code> 值日</li><li><code>at work</code> 在工作</li><li><code>on time</code> 准时</li><li><code>for example</code> 例如</li><li><code>in class</code> 在上课</li><li><code>on show</code> 展览</li><li><code>in bed</code> 在床上</li></ul></li><li><p><strong>go</strong>短语：</p><ul><li><code>go home</code> 回家</li><li><code>go to bed</code> 上床睡觉</li><li><code>go to school</code> 去上学</li><li><code>go to work</code> 去上班</li><li><code>go shopping / swimming / boating / fishing</code> 去买东西 / 游泳 / 划船 / 钓鱼</li></ul></li></ol></li></ol><h2 id="七-泛指概念的四种表达方式"><a href="#七-泛指概念的四种表达方式" class="headerlink" title="七.泛指概念的四种表达方式"></a>七.泛指概念的四种表达方式</h2><ol><li>不带<code>the</code>的<strong>不可数名词</strong>可以表示泛指。如：<ul><li><code>I like music.</code><br>我喜欢音乐。</li></ul></li><li>不带<code>the</code>的<strong>复数可数名词</strong>表示泛指。如：<ul><li><code>Bananas are yellow.</code><br>香蕉是黄色的。</li></ul></li><li>“<code>the</code> + <strong>单数可数名词</strong>”可以表示泛指。如：<ul><li><code>The elephant is the largest land mammal.</code><br>大象是陆地上最大的哺乳动物。</li></ul></li><li>“不定冠词<code>a/an</code> + <strong>单数可数名词</strong>” 可以表示泛指。如：<ul><li><code>A dog makes good pet.</code><br>狗是很好的宠物。</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 英语 </category>
          
          <category> 语法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 英语 </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
