<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>Hello World</title>
      <link href="/post/hello-world.html"/>
      <url>/post/hello-world.html</url>
      
        <content type="html"><![CDATA[<p><img src="/upload_image/test.jpg" alt=""></p><p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p><p>cover: <a href="http://ww3.sinaimg.cn/large/7853084cgw1f7vueqesr5j21jk0uh446.jpg" target="_blank" rel="noopener">http://ww3.sinaimg.cn/large/7853084cgw1f7vueqesr5j21jk0uh446.jpg</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> first </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java面试</title>
      <link href="/post/Java%E9%9D%A2%E8%AF%95.html"/>
      <url>/post/Java%E9%9D%A2%E8%AF%95.html</url>
      
        <content type="html"><![CDATA[<blockquote class="blockquote-center">网络上搜集的面试题</blockquote><h2 id="多线程面试题"><a href="#多线程面试题" class="headerlink" title="多线程面试题"></a>多线程面试题</h2><h3 id="进程和线程之间有什么不同？"><a href="#进程和线程之间有什么不同？" class="headerlink" title="进程和线程之间有什么不同？"></a>进程和线程之间有什么不同？</h3><p>一个进程是一个独立(self contained)的运行环境，它可以被看作一个程序或者一个应用。而线程是在进程中执行的一个任务。Java运行环境是一个包含了不同的类和程序的单一进程。线程可以v c被称为轻量级进程。线程需要较少的资源来创建和驻留在进程中，并且可以共享进程中的资源。</p><h3 id="多线程编程的好处是什么？"><a href="#多线程编程的好处是什么？" class="headerlink" title="多线程编程的好处是什么？"></a>多线程编程的好处是什么？</h3><p>在多线程程序中，多个线程被并发的执行以提高程序的效率，CPU不会因为某个线程需要等待资源而进入空闲状态。多个线程共享堆内存(heap memory)，因此创建多个线程去执行一些任务会比创建多个进程更好。举个例子，Servlets比CGI更好，是因为Servlets支持多线程而CGI不支持。</p><h3 id="用户线程和守护线程有什么区别？"><a href="#用户线程和守护线程有什么区别？" class="headerlink" title="用户线程和守护线程有什么区别？"></a>用户线程和守护线程有什么区别？</h3><p>当我们在Java程序中创建一个线程，它就被称为用户线程。一个守护线程是在v后台执行并且不会阻止JVM终止的线程。当没有用户线程在运行的时候，JVM关闭程序并且退出。一个守护线程创建的子线程依然是守护线程。</p><h3 id="我们如何创建一个线程？"><a href="#我们如何创建一个线程？" class="headerlink" title="我们如何创建一个线程？"></a>我们如何创建一个线程？</h3><p>有两种创建线程的方法：<br>一、实现<strong>Runnable</strong>接口，然后将它传递给Thread的构造函数，创建一个<strong>Thread</strong>对象；<br>二、直接继承<strong>Thread</strong>类。</p><h3 id="有哪些不同的线程生命周期？"><a href="#有哪些不同的线程生命周期？" class="headerlink" title="有哪些不同的线程生命周期？"></a>有哪些不同的线程生命周期？</h3><p>当我们在Java程序中新建一个线程时，它的状态是New。当我们调用线程的<code>start()</code>方法时，状态被改变为<strong>Runnable</strong>。线程调度器会为<strong>Runnable</strong>线程池中的线程分配CPU时间并且讲它们的状态改变为<code>Running</code>。其他的线程状态还有<code>Waiting</code>，<code>Blocked</code>和<code>Dead</code>。</p><h3 id="可以直接调用Thread类的run-方法么？"><a href="#可以直接调用Thread类的run-方法么？" class="headerlink" title="可以直接调用Thread类的run()方法么？"></a>可以直接调用Thread类的run()方法么？</h3><p>当然可以，但是如果我们调用了<strong>Thread</strong>的<code>run()</code>方法，它的行为就会和普通的方法一样，为了在新的线程中执行我们的代码，必须使用<strong>Thread</strong>的<code>start()</code>方法。</p><h3 id="如何让正在运行的线程暂停一段时间？"><a href="#如何让正在运行的线程暂停一段时间？" class="headerlink" title="如何让正在运行的线程暂停一段时间？"></a>如何让正在运行的线程暂停一段时间？</h3><p>我们可以使用Thread类的<code>Sleep()</code>方法让线程暂停一段时间。需要注意的是，这并不会让线程终止，一旦从休眠中唤醒线程，线程的状态将会被改变为<strong>Runnable</strong>，并且根据线程调度，它将得到执行。</p><h3 id="你对线程优先级的理解是什么？"><a href="#你对线程优先级的理解是什么？" class="headerlink" title="你对线程优先级的理解是什么？"></a>你对线程优先级的理解是什么？</h3><p>每一个线程都是有优先级的，一般来说，高优先级的线程在运行时会具有优先权，但这依赖于线程调度的实现，这个实现是和操作系统相关的(OS dependent)。我们可以定义线程的优先级，但是这并不能保证高优先级的线程会在低优先级的线程前执行。线程优先级是一个int变量(从1-10)，1代表最低优先级，10代表最高优先级。</p><h3 id="什么是线程调度器-Thread-Scheduler-和时间分片-Time-Slicing-？"><a href="#什么是线程调度器-Thread-Scheduler-和时间分片-Time-Slicing-？" class="headerlink" title="什么是线程调度器(Thread Scheduler)和时间分片(Time Slicing)？"></a>什么是线程调度器(Thread Scheduler)和时间分片(Time Slicing)？</h3><p>线程调度器是一个操作系统服务，它负责为<strong>Runnable</strong>状态的线程分配CPU时间。一旦我们创建一个线程并启动它，它的执行便依赖于线程调度器的实现。时间分片是指将可用的CPU时间分配给可用的<strong>Runnable</strong>线程的过程。分配CPU时间可以基于线程优先级或者线程等待的时间。线程调度并不受到Java虚拟机控制，所以由应用程序来控制它是更好的选择（也就是说不要让你的程序依赖于线程的优先级）。</p><h3 id="在多线程中，什么是上下文切换-context-switching-？"><a href="#在多线程中，什么是上下文切换-context-switching-？" class="headerlink" title="在多线程中，什么是上下文切换(context-switching)？"></a>在多线程中，什么是上下文切换(context-switching)？</h3><p>上下文切换是存储和恢复CPU状态的过程，它使得线程执行能够从中断点恢复执行。上下文切换是多任务操作系统和多线程环境的基本特征。</p><h3 id="你如何确保main-方法所在的线程是Java程序最后结束的线程？"><a href="#你如何确保main-方法所在的线程是Java程序最后结束的线程？" class="headerlink" title="你如何确保main()方法所在的线程是Java程序最后结束的线程？"></a>你如何确保main()方法所在的线程是Java程序最后结束的线程？</h3><p>我们可以使用<strong>Thread</strong>类的<code>joint()</code>方法来确保所有程序创建的线程在<code>main()</code>方法退出前结束。这里有一篇文章关于<strong>Thread</strong>类的<code>joint()</code>方法。</p><h3 id="线程之间是如何通信的？"><a href="#线程之间是如何通信的？" class="headerlink" title="线程之间是如何通信的？"></a>线程之间是如何通信的？</h3><p>当线程间是可以共享资源时，线程间通信是协调它们的重要的手段。<strong>Object</strong>类中<code>wait()</code>，<code>notify()</code>，<code>notifyAll()</code>方法可以用于线程间通信关于资源的锁的状态。</p><h3 id="为什么线程通信的方法wait-notify-和notifyAll-被定义在Object类里？"><a href="#为什么线程通信的方法wait-notify-和notifyAll-被定义在Object类里？" class="headerlink" title="为什么线程通信的方法wait(), notify()和notifyAll()被定义在Object类里？"></a>为什么线程通信的方法wait(), notify()和notifyAll()被定义在Object类里？</h3><p>Java的每个对象中都有一个锁(monitor，也可以成为监视器) 并且<code>wait()</code>，<code>notify()</code>等方法用于等待对象的锁或者通知其他线程对象的监视器可用。在Java的线程中并没有可供任何对象使用的锁和同步器。这就是为什么这些方法是<strong>Object</strong>类的一部分，这样Java的每一个类都有用于线程间通信的基本方法。</p><h3 id="为什么wait-notify-和notifyAll-必须在同步方法或者同步块中被调用？"><a href="#为什么wait-notify-和notifyAll-必须在同步方法或者同步块中被调用？" class="headerlink" title="为什么wait(), notify()和notifyAll()必须在同步方法或者同步块中被调用？"></a>为什么wait(), notify()和notifyAll()必须在同步方法或者同步块中被调用？</h3><p>当一个线程需要调用对象的<code>wait()</code>方法的时候，这个线程必须拥有该对象的锁，接着它就会释放这个对象锁并进入等待状态直到其他线程调用这个对象上的<code>notify()</code>方法。同样的，当一个线程需要调用对象的<code>notify()</code>方法时，它会释放这个对象的锁，以便其他在等待的线程就可以得到这个对象锁。由于所有的这些方法都需要线程持有对象的锁，这样就只能通过同步来实现，所以他们只能在同步方法或者同步块中被调用。</p><h3 id="为什么Thread类的sleep-和yield-方法是静态的？"><a href="#为什么Thread类的sleep-和yield-方法是静态的？" class="headerlink" title="为什么Thread类的sleep()和yield()方法是静态的？"></a>为什么Thread类的sleep()和yield()方法是静态的？</h3><p><strong>Thread</strong>类的<code>sleep()</code>和<code>yield()</code>方法将在当前正在执行的线程上运行。所以在其他处于等待状态的线程上调用这些方法是没有意义的。这就是为什么这些方法是静态的。它们可以在当前正在执行的线程中工作，并避免程序员错误的认为可以在其他非运行线程调用这些方法。</p><h3 id="如何确保线程安全？"><a href="#如何确保线程安全？" class="headerlink" title="如何确保线程安全？"></a>如何确保线程安全？</h3><p>在Java中可以有很多方法来保证线程安全——同步，使用原子类(atomic concurrent classes)，实现并发锁，使用<strong>volatile</strong>关键字，使用不变类和线程安全类。</p><h3 id="volatile关键字在Java中有什么作用？"><a href="#volatile关键字在Java中有什么作用？" class="headerlink" title="volatile关键字在Java中有什么作用？"></a>volatile关键字在Java中有什么作用？</h3><p>当我们使用volatile关键字去修饰变量的时候，所以线程都会直接读取该变量并且不缓存它。这就确保了线程读取到的变量是同内存中是一致的。</p><h3 id="同步方法和同步块，哪个是更好的选择？"><a href="#同步方法和同步块，哪个是更好的选择？" class="headerlink" title="同步方法和同步块，哪个是更好的选择？"></a>同步方法和同步块，哪个是更好的选择？</h3><p>同步块是更好的选择，因为它不会锁住整个对象（当然你也可以让它锁住整个对象）。同步方法会锁住整个对象，哪怕这个类中有多个不相关联的同步块，这通常会导致他们停止执行并需要等待获得这个对象上的锁。</p><h3 id="如何创建守护线程？"><a href="#如何创建守护线程？" class="headerlink" title="如何创建守护线程？"></a>如何创建守护线程？</h3><p>使用<strong>Thread</strong>类的<code>setDaemon(true)</code>方法可以将线程设置为守护线程，需要注意的是，需要在调用<code>start()</code>方法前调用这个方法，否则会抛出<strong>IllegalThreadStateException</strong>异常。</p><h3 id="什么是ThreadLocal"><a href="#什么是ThreadLocal" class="headerlink" title="什么是ThreadLocal?"></a>什么是ThreadLocal?</h3><p><strong>ThreadLocal</strong>用于创建线程的本地变量，我们知道一个对象的所有线程会共享它的全局变量，所以这些变量不是线程安全的，我们可以使用同步技术。但是当我们不想使用同步的时候，我们可以选择<strong>ThreadLocal</strong>变量。<br>每个线程都会拥有他们自己的<strong>Thread</strong>变量，它们可以使用<code>get()</code>，<code>set()</code>方法去获取他们的默认值或者在线程内部改变他们的值。<strong>ThreadLocal</strong>实例通常是希望它们同线程状态关联起来是<strong>private static</strong>属性。</p><h3 id="什么是Thread-Group？为什么建议使用它？"><a href="#什么是Thread-Group？为什么建议使用它？" class="headerlink" title="什么是Thread Group？为什么建议使用它？"></a>什么是Thread Group？为什么建议使用它？</h3><p><strong>ThreadGroup</strong>是一个类，它的目的是提供关于线程组的信息。<br><strong>ThreadGroup API</strong>比较薄弱，它并没有比<strong>Thread</strong>提供了更多的功能。它有两个主要的功能：一是获取线程组中处于活跃状态线程的列表；二是设置为线程设置未捕获异常处理器(ncaught exception handler)。但在Java 1.5中Thread类也添加了<code>setUncaughtExceptionHandler(UncaughtExceptionHandler eh)</code>方法，所以<strong>ThreadGroup</strong>是已经过时的，不建议继续使用。<br><code>1t1.setUncaughtExceptionHandler(newUncaughtExceptionHandler(){23@Override4publicvoiduncaughtException(Thread t, Throwable e) {5System.out.println(&quot;exception occured:&quot;+e.getMessage());6}78});</code></p><h3 id="什么是Java线程转储-Thread-Dump-，如何得到它？"><a href="#什么是Java线程转储-Thread-Dump-，如何得到它？" class="headerlink" title="什么是Java线程转储(Thread Dump)，如何得到它？"></a>什么是Java线程转储(Thread Dump)，如何得到它？</h3><p>线程转储是一个JVM活动线程的列表，它对于分析系统瓶颈和死锁非常有用。有很多方法可以获取线程转储——使用<code>Profiler，Kill -3</code>命令，<strong>jstack</strong>工具等等。我更喜欢jstack工具，因为它容易使用并且是JDK自带的。由于它是一个基于终端的工具，所以我们可以编写一些脚本去定时的产生线程转储以待分析。</p><h3 id="什么是死锁-Deadlock-？如何分析和避免死锁？"><a href="#什么是死锁-Deadlock-？如何分析和避免死锁？" class="headerlink" title="什么是死锁(Deadlock)？如何分析和避免死锁？"></a>什么是死锁(Deadlock)？如何分析和避免死锁？</h3><p>死锁是指两个以上的线程永远阻塞的情况，这种情况产生至少需要两个以上的线程和两个以上的资源。<br>分析死锁，我们需要查看Java应用程序的线程转储。我们需要找出那些状态为<strong>BLOCKED</strong>的线程和他们等待的资源。每个资源都有一个唯一的id，用这个id我们可以找出哪些线程已经拥有了它的对象锁。<br>避免嵌套锁，只在需要的地方使用锁和避免无限期等待是避免死锁的通常办法。</p><h3 id="什么是Java-Timer类？如何创建一个有特定时间间隔的任务？"><a href="#什么是Java-Timer类？如何创建一个有特定时间间隔的任务？" class="headerlink" title="什么是Java Timer类？如何创建一个有特定时间间隔的任务？"></a>什么是Java Timer类？如何创建一个有特定时间间隔的任务？</h3><p><strong>java.util.Timer</strong>是一个工具类，可以用于安排一个线程在未来的某个特定时间执行。<strong>Timer</strong>类可以用安排一次性任务或者周期任务。<br><strong>java.util.TimerTask</strong>是一个实现了<strong>Runnable</strong>接口的抽象类，我们需要去继承这个类来创建我们自己的定时任务并使用<strong>Timer</strong>去安排它的执行。</p><h3 id="什么是线程池？如何创建一个Java线程池？"><a href="#什么是线程池？如何创建一个Java线程池？" class="headerlink" title="什么是线程池？如何创建一个Java线程池？"></a>什么是线程池？如何创建一个Java线程池？</h3><p>一个线程池管理了一组工作线程，同时它还包括了一个用于放置等待执行的任务的队列。<br><strong>java.util.concurrent.Executors</strong>提供了一个<strong>java.util.concurrent.Executor</strong>接口的实现用于创建线程池。</p><hr><hr><h2 id="并发面试问题"><a href="#并发面试问题" class="headerlink" title="并发面试问题"></a>并发面试问题</h2><h3 id="什么是原子操作？在Java-Concurrency-API中有哪些原子类-atomic-classes-？"><a href="#什么是原子操作？在Java-Concurrency-API中有哪些原子类-atomic-classes-？" class="headerlink" title="什么是原子操作？在Java Concurrency API中有哪些原子类(atomic classes)？"></a>什么是原子操作？在Java Concurrency API中有哪些原子类(atomic classes)？</h3><p>原子操作是指一个不受其他操作影响的操作任务单元。原子操作是在多线程环境下避免数据不一致必须的手段。<br><code>int++</code>并不是一个原子操作，所以当一个线程读取它的值并加1时，另外一个线程有可能会读到之前的值，这就会引发错误。<br>为了解决这个问题，必须保证增加操作是原子的，在JDK1.5之前我们可以使用同步技术来做到这一点。到JDK1.5，<strong>java.util.concurrent.atomic</strong>包提供了<code>int</code>和<code>long</code>类型的装类，它们可以自动的保证对于他们的操作是原子的并且不需要使用同步。</p><h3 id="Java-Concurrency-API中的Lock接口-Lock-interface-是什么？对比同步它有什么优势？"><a href="#Java-Concurrency-API中的Lock接口-Lock-interface-是什么？对比同步它有什么优势？" class="headerlink" title="Java Concurrency API中的Lock接口(Lock interface)是什么？对比同步它有什么优势？"></a>Java Concurrency API中的Lock接口(Lock interface)是什么？对比同步它有什么优势？</h3><p><strong>Lock</strong>接口比同步方法和同步块提供了更具扩展性的锁操作。他们允许更灵活的结构，可以具有完全不同的性质，并且可以支持多个相关类的条件对象。<br>它的优势有：<br>可以使锁更公平;<br>可以使线程在等待锁的时候响应中断;<br>可以让线程尝试获取锁，并在无法获取锁的时候立即返回或者等待一段时间;<br>可以在不同的范围，以不同的顺序获取和释放锁。</p><h3 id="什么是Executors框架？"><a href="#什么是Executors框架？" class="headerlink" title="什么是Executors框架？"></a>什么是Executors框架？</h3><p><strong>Executor</strong>框架同<strong>java.util.concurrent.Executor</strong>接口在Java 5中被引入。<strong>Executor</strong>框架是一个根据一组执行策略调用，调度，执行和控制的异步任务的框架。<br>无限制的创建线程会引起应用程序内存溢出。所以创建一个线程池是个更好的的解决方案，因为可以限制线程的数量并且可以回收再利用这些线程。</p><h3 id="什么是阻塞队列？如何使用阻塞队列来实现生产者-消费者模型？"><a href="#什么是阻塞队列？如何使用阻塞队列来实现生产者-消费者模型？" class="headerlink" title="什么是阻塞队列？如何使用阻塞队列来实现生产者-消费者模型？"></a>什么是阻塞队列？如何使用阻塞队列来实现生产者-消费者模型？</h3><p><strong>java.util.concurrent.BlockingQueue</strong>的特性是：当队列是空的时，从队列中获取或删除元素的操作将会被阻塞，或者当队列是满时，往队列里添加元素的操作会被阻塞。<br>阻塞队列不接受空值，当你尝试向队列中添加空值的时候，它会抛出<strong>NullPointerException</strong>。<br>阻塞队列的实现都是线程安全的，所有的查询方法都是原子的并且使用了内部锁或者其他形式的并发控制。<br><strong>BlockingQueue</strong>接口是<strong>collections</strong>框架的一部分，它主要用于实现生产者-消费者问题。</p><h3 id="什么是Callable和Future"><a href="#什么是Callable和Future" class="headerlink" title="什么是Callable和Future?"></a>什么是Callable和Future?</h3><p>Java 5在<strong>concurrency</strong>包中引入了<strong>java.util.concurrent.Callable</strong>接口，它和<strong>Runnable</strong>接口很相似，但它可以返回一个对象或者抛出一个异常。<br><strong>Callable</strong>接口使用泛型去定义它的返回类型。<strong>Executors</strong>类提供了一些有用的方法去在线程池中执行<strong>Callable</strong>内的任务。由于<strong>Callable</strong>任务是并行的，我们必须等待它返回的结果。<strong>java.util.concurrent.Future</strong>对象为我们解决了这个问题。在线程池提交<strong>Callable</strong>任务后返回了一个<strong>Future</strong>对象，使用它我们可以知道<strong>Callable</strong>任务的状态和得到<strong>Callable</strong>返回的执行结果。<strong>Future</strong>提供了<code>get()</code>方法让我们可以等待<strong>Callable</strong>结束并获取它的执行结果。</p><h3 id="什么是FutureTask-v"><a href="#什么是FutureTask-v" class="headerlink" title="什么是FutureTask?v"></a>什么是FutureTask?v</h3><p><strong>FutureTask</strong>是<strong>Future</strong>的一个基础实现，我们可以将它同<strong>Executors</strong>使用处理异步任务。通常我们不需要使用<strong>FutureTask</strong>类，单当我们打算重写<strong>Future</strong>接口的一些方法并保持原来基础的实现是，它就变得非常有用。我们可以仅仅继承于它并重写我们需要的方法。</p><h3 id="什么是并发容器的实现？"><a href="#什么是并发容器的实现？" class="headerlink" title="什么是并发容器的实现？"></a>什么是并发容器的实现？</h3><p>Java集合类都是快速失败的，这就意味着当集合被改变且一个线程在使用迭代器遍历集合的时候，迭代器的<code>next()</code>方法将抛出<strong>ConcurrentModificationException</strong>异常。<br>并发容器支持并发的遍历和并发的更新。<br>主要的类有<strong>ConcurrentHashMap</strong>, <strong>CopyOnWriteArrayList</strong>和<strong>CopyOnWriteArraySet</strong>。</p><h3 id="Executors类是什么？"><a href="#Executors类是什么？" class="headerlink" title="Executors类是什么？"></a>Executors类是什么？</h3><p><strong>Executors</strong>为<strong>Executor</strong>，<strong>ExecutorService</strong>，<strong>ScheduledExecutorService</strong>，<strong>ThreadFactory</strong>和<strong>Callable</strong>类提供了一些工具方法。<br><strong>Executors</strong>可以用于方便的创建线程池。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> 面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>String学习笔记</title>
      <link href="/post/String%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html"/>
      <url>/post/String%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html</url>
      
        <content type="html"><![CDATA[<blockquote class="blockquote-center">String相关</blockquote><h2 id="String常用API"><a href="#String常用API" class="headerlink" title="String常用API"></a>String常用API</h2><p>1.返回给定位置的代码单元。(偏底层代码单元，一般不使用)<br><code>char charAt(int index)</code></p><p>2.返回从给定位置开始的码点。<br><code>int codePointAt(int index)</code></p><p>3.按照字典顺序，如果字符串位于other之前，返回一个负数；如果字符串位于other之后，返回一个正数；如果两个字符串相等，返回0.<br><code>int compareTo(String other)</code></p><p>4.将这个字符串的码点作为一个流返回。调用toArray将它们放在一个数组中。<br><code>IntStream codePoints()</code></p><p>5.用数组中从offset开始的count个码点构造一个字符串。<br><code>new String(int[] codePoints, int offset, int count)</code></p><p>6.如果字符串与other相等，返回true。<br><code>boolean equals(Object other)</code></p><p>7.如果字符串与other相等(忽略大小写)，返回true。<br><code>boolean equalsIgnoreCase(String other)</code></p><p>8.如果字符串以suffix开头或结尾，返回true。<br><code>boolean startsWith(String prefix)</code><br><code>boolean endsWith(String suffix)</code></p><p>9.返回与字符串str或代码点cp匹配的第一个子串的开始位置。这个位置从索引0或fromIndex开始计算。如果在原始串中不存在str，返回-1。<br><code>int indexOf(String str)</code><br><code>int indexOf(String str, int fromIndex)</code><br><code>int indexOf(int cp)</code><br><code>int indexOf(int cp, int fromIndex)</code></p><p>10.返回与字符串str或代码点cp匹配的最后一个子串的开始位置。这个位置从原始串尾端或fromIndex开始计算。<br><code>int lastIndexOf(String str)</code><br><code>int lastIndexOf(String str, int fromIndex)</code><br><code>int lastIndexOf(int cp)</code><br><code>int lastIndexOf(int cp, int fromIndex)</code></p><p>11.返回字符串的长度。<br><code>int length()</code></p><p>12.返回一个新字符串。这个字符串用newString代替原始字符串中所有的oldString。可以用Stirng或StringBuilder对象作为CharSequence参数。<br><code>String replace(CharSequence oldString, charSequence newString)</code></p><p>13.返回一个新字符串。这个字符串包含原始字符串中从从beginIndex到串尾或endIndex-1的所有代码单元。<br><code>String substing(int beginIndex)</code><br><code>String substing(int beginIndex, int endIndex)</code></p><p>14.返回一个新字符串。这个字符串将原始字符串中的大写字母改成小写字母。<br><code>String toLowerCase()</code></p><p>15.返回一个新字符串。这个字符串将原始字符串中的小写字母改成大写字母。<br><code>String toUpperCase()</code></p><p>16.返回一个新字符串。这个字符串将删除原始字符串头部和尾部的空格。<br><code>String trim()</code></p><p>17.返回一个新字符串。用给定的定界符连接所有元素。<br><code>String join(charSequence delimiter, charSequence... elements)</code></p><p>18.返回从startIndex代码点开始，位移cpCount后的码点索引。<br><code>int offsetByCodePoints(int startIndex, int cpCount)</code></p><p>19.返回startIndex和endIndex-1之间的代码点数量。没有配成对的代用字符将计入代码点。<br><code>int codePointCount(int startIndex, int endIndex)</code></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
